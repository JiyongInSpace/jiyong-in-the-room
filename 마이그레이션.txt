단계별 구현 계획 - 로컬 우선 아키텍처 전환

  📋 Phase 1: 읽기 최적화 (1주차)

  목표: 앱 시작 및 화면 전환 속도 대폭 개선

  1-1. 로컬 캐시 레이어 구축

  // lib/services/cache_service.dart 생성
  class CacheService {
    // 회원도 로컬 캐시 사용
    static Future<List<DiaryEntry>> getCachedDiaries() async {
      // 1. 로컬 캐시 확인
      // 2. 없으면 DB에서 로드 후 캐시
      // 3. 백그라운드에서 최신 데이터 체크
    }
  }

  1-2. 메인 화면 즉시 로딩

  - HomeScreen: 로컬 데이터 우선 표시
  - 통계: 로컬에서 계산
  - 백그라운드 리프레시

  1-3. 테마/카페 데이터 캐싱

  - 앱 시작 시 한 번만 로드
  - 로컬에 저장 후 재사용
  - 주기적 업데이트 (1일 1회)

  예상 효과: 앱 시작 2-3초 → 0.1초

  ---
  📋 Phase 2: 쓰기 최적화 (2주차)

  목표: 즉각적인 UI 반응

  2-1. Optimistic UI 패턴 적용

  // 일지 작성 시
  Future<void> saveDiary(DiaryEntry entry) async {
    // 1. 로컬 저장 (즉시)
    await LocalStorage.saveDiary(entry);
    setState(() => diaries.add(entry)); // UI 즉시 업데이트

    // 2. DB 저장 (백그라운드)
    try {
      await DatabaseService.saveDiary(entry);
      entry.syncStatus = 'synced';
    } catch (e) {
      entry.syncStatus = 'pending';
      SyncQueue.add(entry);
    }
  }

  2-2. 동기화 상태 표시

  - 각 아이템에 작은 동기화 아이콘
  - pending: 🔄 (주황색)
  - synced: ✓ (초록색)
  - error: ⚠️ (빨간색)

  2-3. 백그라운드 동기화 큐

  class SyncQueue {
    // 5초마다 pending 항목 재시도
    // 실패 시 exponential backoff
    // 최대 재시도 5회
  }

  ---
  📋 Phase 3: 충돌 해결 (3주차)

  목표: 다중 기기 지원

  3-1. 타임스탬프 기반 버전 관리

  class DiaryEntry {
    DateTime localUpdatedAt;   // 로컬 수정 시간
    DateTime? serverUpdatedAt; // 서버 수정 시간
    String deviceId;           // 기기 식별자
  }

  3-2. 3-way merge 구현

  // 충돌 감지 및 해결
  if (local.updatedAt != server.updatedAt) {
    if (local.localUpdatedAt > server.serverUpdatedAt) {
      // 로컬이 최신 → 서버 덮어쓰기
    } else {
      // 서버가 최신 → 사용자에게 선택 요청
      showConflictDialog(local, server);
    }
  }

  3-3. 선택적 동기화

  - 설정에서 동기화 on/off
  - Wi-Fi에서만 동기화 옵션
  - 수동 동기화 버튼

  ---
  📋 Phase 4: 고급 기능 (4주차)

  목표: 완벽한 오프라인 경험

  4-1. 차등 동기화

  // 변경된 부분만 동기화
  class SyncDelta {
    String fieldName;
    dynamic oldValue;
    dynamic newValue;
    DateTime timestamp;
  }

  4-2. 압축 및 배치 처리

  - 여러 변경사항 한 번에 전송
  - gzip 압축으로 트래픽 절감

  4-3. 동기화 분석 대시보드

  - 동기화 통계 (성공/실패)
  - 데이터 사용량
  - 충돌 히스토리

  ---
  📋 Phase 5: 마이그레이션 (5주차)

  목표: 기존 사용자 무중단 전환

  5-1. 점진적 마이그레이션

  // 앱 업데이트 시
  if (isFirstLaunchAfterUpdate) {
    showMigrationDialog();
    // "더 빠른 앱을 위해 데이터를 최적화합니다"
    await migrateToLocalFirst();
  }

  5-2. 롤백 계획

  - 이전 버전 데이터 백업
  - 문제 발생 시 복구 옵션

  ---
  🎯 구현 우선순위 매트릭스

  | Phase     | 난이도   | 효과    | 리스크  | 추천 순서 |
  |-----------|-------|-------|------|-------|
  | 1. 읽기 최적화 | ⭐⭐    | ⭐⭐⭐⭐⭐ | ⭐    | 1번    |
  | 2. 쓰기 최적화 | ⭐⭐⭐   | ⭐⭐⭐⭐  | ⭐⭐   | 2번    |
  | 3. 충돌 해결  | ⭐⭐⭐⭐  | ⭐⭐⭐   | ⭐⭐⭐  | 4번    |
  | 4. 고급 기능  | ⭐⭐⭐⭐⭐ | ⭐⭐    | ⭐⭐   | 5번    |
  | 5. 마이그레이션 | ⭐⭐⭐   | ⭐⭐⭐⭐  | ⭐⭐⭐⭐ | 3번    |

  ---
  🚀 Quick Win 전략

  즉시 구현 가능한 것들 (1-2일):
  1. 홈 화면 로컬 캐시
  2. 친구 목록 로컬 캐시
  3. 테마/카페 검색 결과 캐싱

  코드 예시:
  // main.dart 수정
  Future<void> loadInitialData() async {
    // 기존: DB에서만 로드
    // diaries = await DatabaseService.getMyDiaries();

    // 개선: 로컬 우선
    diaries = await LocalStorage.getDiaries() ?? [];
    setState(() {}); // 즉시 UI 표시

    // 백그라운드 동기화
    Future.microtask(() async {
      final serverDiaries = await DatabaseService.getMyDiaries();
      if (serverDiaries != diaries) {
        setState(() => diaries = serverDiaries);
        await LocalStorage.saveDiaries(serverDiaries);
      }
    });
  }

  이렇게 단계별로 진행하면 리스크를 최소화하면서도 빠르게 성능 개선을 체감할 수 있습니다.





오프라인 처리 전략

  1. 기본 원칙: 로컬 우선, 네트워크는 선택적

  온라인/오프라인 구분 없이 동일한 UX 제공
  - 로컬이 진짜 데이터
  - DB는 백업/동기화용

  2. 상태별 동작 시나리오

  📱 완전 오프라인 상태

  // 모든 작업이 로컬에서만 처리
  - 일지 작성 → Hive 저장 → 동기화 큐에 추가
  - 친구 추가 → Hive 저장 → 동기화 큐에 추가
  - 수정/삭제 → Hive 수정 → 동기화 큐에 추가

  // 동기화 큐 구조
  SyncQueue {
    id: local_timestamp_123,
    type: 'CREATE_DIARY',
    data: DiaryEntry,
    status: 'pending',
    retryCount: 0,
    createdAt: DateTime
  }

  🔄 온라인 복귀 시

  // 자동 동기화 프로세스
  1. 동기화 큐 확인
  2. pending 항목들 순차 처리
  3. 성공 → 큐에서 제거
  4. 실패 → retryCount++, 나중에 재시도

  3. 충돌 해결 전략

  시나리오 1: 같은 사용자, 다른 기기

  기기 A (오프라인): 일지 작성
  기기 B (온라인): 같은 날 다른 일지 작성

  해결: 둘 다 유지 (병합)
  - 같은 날 여러 일지 가능하므로 충돌 아님

  시나리오 2: 수정 충돌

  기기 A: 일지 수정 (오프라인)
  기기 B: 같은 일지 수정 (온라인)

  해결: Last-Write-Wins (타임스탬프 기준)
  - 각 수정에 localTimestamp + deviceId 포함
  - 최신 것으로 덮어쓰기

  4. 구체적인 구현 방법

  Step 1: 동기화 상태 표시

  class DiaryEntry {
    // 기존 필드들...

    // 동기화 메타데이터 추가
    DateTime? lastSyncedAt;
    bool hasLocalChanges = false;
    String? syncError;
  }

  // UI에 동기화 상태 표시
  Widget buildSyncIndicator(DiaryEntry entry) {
    if (entry.hasLocalChanges) {
      return Icon(Icons.cloud_upload, color: Colors.orange); // 동기화 대기
    } else if (entry.syncError != null) {
      return Icon(Icons.cloud_off, color: Colors.red); // 동기화 실패
    } else {
      return Icon(Icons.cloud_done, color: Colors.green); // 동기화 완료
    }
  }

  Step 2: 동기화 매니저

  class SyncManager {
    // 백그라운드에서 주기적 실행
    Future<void> syncAll() async {
      if (!isOnline) return;

      // 1. 로컬 변경사항 업로드
      final pendingChanges = await LocalStorage.getPendingChanges();
      for (final change in pendingChanges) {
        try {
          await uploadChange(change);
          await LocalStorage.markAsSynced(change.id);
        } catch (e) {
          // 실패 시 재시도 큐에 유지
        }
      }

      // 2. 서버 변경사항 다운로드 (선택적)
      final serverChanges = await getServerChangesSince(lastSyncTime);
      await mergeServerChanges(serverChanges);
    }
  }

  5. 특수 기능 처리

  🔍 테마/카페 검색 (공통 데이터)

  // 전략: 주기적 캐싱
  - 앱 시작 시 테마/카페 목록 다운로드 → 로컬 캐시
  - 오프라인에서는 캐시된 데이터 사용
  - 온라인 복귀 시 백그라운드 업데이트

  👥 친구 코드 연동

  // 오프라인에서는 불가능
  - "네트워크 연결 후 시도해주세요" 안내
  - 또는 코드 저장 후 온라인 시 자동 연동

  6. 사용자 경험 최적화

  // 투명한 오프라인 경험
  1. 오프라인 배너 최소화 (작게, 필요시만)
  2. 모든 기능 사용 가능 (네트워크 필수 기능 제외)
  3. 동기화는 백그라운드에서 조용히
  4. 충돌 발생 시만 사용자에게 선택 요청

  7. 구현 우선순위

  Phase 1 (즉시 구현 가능)
  - 읽기를 로컬 우선으로 변경
  - 쓰기는 로컬 + DB 동시 저장

  Phase 2
  - 오프라인 쓰기 큐 구현
  - 자동 동기화

  Phase 3
  - 충돌 해결
  - 다중 기기 지원

  이렇게 하면 오프라인에서도 거의 모든 기능을 사용할 수 있고, 온라인 복귀 시 자동으로 동기화됩니다. 사용자는 네트워크 상태를 거의 신경 쓸 필요가 없게 됩니다.



ID 체계 통합 전략

  📌 현재 상황 분석

  // 현재 코드
  - 로컬 ID: 음수 (예: -1, -2, -3...)
  - DB ID: 양수 SERIAL (예: 1, 2, 3...)
  - 문제: 동일 데이터가 다른 ID를 가짐

  🔑 해결 방안: UUID 기반 통합 ID

  Option 1: UUID 전면 도입 (추천)

  class DiaryEntry {
    String id;  // UUID (예: "550e8400-e29b-41d4-a716-446655440000")
    int? legacyId;  // 기존 DB의 SERIAL ID (마이그레이션용)

    DiaryEntry.create() {
      id = Uuid().v4();  // 로컬에서 즉시 생성
    }
  }

  장점:
  - 로컬에서 생성 즉시 영구 ID 부여
  - 충돌 가능성 사실상 0%
  - 다중 기기에서도 안전

  DB 스키마 변경:
  ALTER TABLE diary_entries
  ADD COLUMN uuid VARCHAR(36) UNIQUE;

  -- 기존 데이터에 UUID 부여
  UPDATE diary_entries
  SET uuid = gen_random_uuid()
  WHERE uuid IS NULL;

  -- 추후 uuid를 PRIMARY KEY로 전환

  Option 2: Hybrid ID (현실적 접근)

  class DiaryEntry {
    String compositeId;  // "local_" 또는 "db_" prefix
    int? dbId;           // DB SERIAL ID
    String? localId;     // 로컬 고유 ID

    // 생성자
    DiaryEntry.createLocal() {
      localId = '${DateTime.now().millisecondsSinceEpoch}_${deviceId}';
      compositeId = 'local_$localId';
    }

    // DB 저장 후
    void syncWithDb(int serverGeneratedId) {
      dbId = serverGeneratedId;
      compositeId = 'db_$serverGeneratedId';
      localId = null;  // 더 이상 불필요
    }
  }

  🔄 마이그레이션 전략

  Phase 1: 기존 데이터 보존

  // 마이그레이션 시작
  class MigrationService {
    static Future<void> addUuidToExisting() async {
      // 1. DB의 기존 데이터에 UUID 추가
      final dbEntries = await DatabaseService.getAllEntries();
      for (final entry in dbEntries) {
        entry.uuid = Uuid().v4();
        await DatabaseService.updateUuid(entry);
      }

      // 2. 로컬의 기존 데이터 매핑
      final localEntries = await LocalStorage.getAllEntries();
      for (final entry in localEntries) {
        if (entry.id < 0) {  // 로컬 전용 데이터
          entry.uuid = Uuid().v4();
          entry.needsSync = true;
        }
      }
    }
  }

  Phase 2: 친구 데이터 통합

  class Friend {
    String id;  // UUID
    int? legacyFriendId;  // 기존 friends.id
    String? connectedUserId;  // 그대로 유지

    // 연결 관계도 UUID로
    Map<String, dynamic> toJson() {
      return {
        'id': id,  // UUID
        'legacy_id': legacyFriendId,
        'connected_user_id': connectedUserId,
        //...
      };
    }
  }

  💾 로컬 저장소 구조 개선

  // Hive 박스 구조 변경
  class LocalStorageService {
    // 기존: ID를 키로 사용
    // Box<DiaryEntry> diaryBox;  // key: int ID

    // 개선: UUID를 키로 사용
    static final Box<String> diaryBox = Hive.box('diary_v2');

    static Future<void> saveDiary(DiaryEntry entry) async {
      // UUID를 키로 사용
      await diaryBox.put(entry.id, entry.toJson());
    }

    static DiaryEntry? getDiary(String uuid) {
      final json = diaryBox.get(uuid);
      return json != null ? DiaryEntry.fromJson(json) : null;
    }
  }

  🔗 참조 무결성 유지

  // 일지-친구 관계도 UUID로
  class DiaryEntryParticipant {
    String diaryId;   // diary UUID
    String? friendId; // friend UUID
    String? userId;   // user UUID (Supabase auth)
  }

  // 조회 시
  static Future<List<Friend>> getDiaryParticipants(String diaryUuid) async {
    // UUID 기반 조회
    final participants = await supabase
      .from('diary_entry_participants')
      .select()
      .eq('diary_uuid', diaryUuid);
    //...
  }

  🚀 구현 순서

  Step 1: 신규 데이터부터 UUID 적용

  // 즉시 적용 가능
  class DiaryEntry {
    late String id;
    int? dbId;  // 임시 보관

    DiaryEntry.create() {
      id = const Uuid().v4();  // 신규 생성 시 UUID
    }
  }

  Step 2: 기존 데이터 점진적 마이그레이션

  // 앱 시작 시 백그라운드에서
  if (needsMigration) {
    await MigrationService.migrateToUuid();
    // 사용자 모르게 조용히 진행
  }

  Step 3: 레거시 ID 제거

  // 모든 데이터 마이그레이션 완료 후
  // 3-6개월 후 레거시 컬럼 제거

  ✅ 체크리스트

  // 영향받는 부분들
  - [ ] diary_entries 테이블: uuid 컬럼 추가
  - [ ] friends 테이블: uuid 컬럼 추가
  - [ ] participants 테이블: uuid 참조로 변경
  - [ ] LocalStorageService: UUID 키 사용
  - [ ] 모든 조회 쿼리: UUID 기반으로 변경
  - [ ] 동기화 로직: UUID로 매칭

  이렇게 UUID로 통일하면 로컬-온라인 구분 없이 동일한 ID로 데이터를 추적할 수 있고, 동기화가 훨씬 간단해집니다!

> 테마나 카페를 검색하는부분은 어떻게 하면 좋을까?\
  그건 온라인이 가능한 경우에만 하게 할까?

⏺ 테마/카페 검색은 하이브리드 방식을 추천합니다! 오프라인에서도 검색 가능하되, 데이터 특성에 맞게 전략을 다르게 가져가는 것이 좋습니다.

  테마/카페 검색 전략

  📊 데이터 특성 분석

  테마 데이터: 약 2000-5000개 추정
  카페 데이터: 약 200-500개 추정
  총 용량: 약 1-2MB (텍스트만)
  변경 빈도: 낮음 (주 1-2회 새 테마 추가)

  🎯 추천 전략: 스마트 캐싱

  1. 초기 다운로드 + 정기 업데이트

  class ThemeCacheService {
    static const Duration CACHE_DURATION = Duration(days: 7);

    // 앱 첫 실행 또는 캐시 만료 시
    static Future<void> initializeCache() async {
      final lastUpdated = LocalStorage.getLastThemeUpdate();

      if (lastUpdated == null ||
          DateTime.now().difference(lastUpdated) > CACHE_DURATION) {
        await downloadAllThemes();
      }
    }

    // 전체 테마/카페 다운로드 (백그라운드)
    static Future<void> downloadAllThemes() async {
      try {
        // 프로그레스 표시
        showDownloadProgress("테마 데이터 업데이트 중...");

        final themes = await DatabaseService.getAllThemes(limit: 5000);
        final cafes = await DatabaseService.getAllCafes();

        // 로컬에 저장
        await LocalStorage.saveThemes(themes);
        await LocalStorage.saveCafes(cafes);
        await LocalStorage.setLastThemeUpdate(DateTime.now());

        // 검색 인덱스 구축
        await buildSearchIndex(themes, cafes);
      } catch (e) {
        // 실패해도 기존 캐시 사용
        print('테마 캐시 업데이트 실패: $e');
      }
    }
  }

  2. 오프라인 검색 최적화

  class OfflineSearchService {
    // 검색 인덱스 (메모리 캐시)
    static Map<String, List<EscapeTheme>> searchIndex = {};

    // 검색 인덱스 구축 (앱 시작 시 1회)
    static Future<void> buildSearchIndex(List<EscapeTheme> themes, List<EscapeCafe> cafes) async {
      // 1. 테마명 인덱싱
      for (final theme in themes) {
        final keywords = _extractKeywords(theme.name);
        for (final keyword in keywords) {
          searchIndex[keyword] ??= [];
          searchIndex[keyword]!.add(theme);
        }
      }

      // 2. 초성 검색 지원
      // "신데렐라" → "ㅅㄷㄹㄹ"
      for (final theme in themes) {
        final chosung = _extractChosung(theme.name);
        searchIndex[chosung] ??= [];
        searchIndex[chosung]!.add(theme);
      }
    }

    // 빠른 로컬 검색
    static List<EscapeTheme> searchThemes(String query) {
      if (query.length < 1) return [];

      final results = <EscapeTheme>{};
      final queryLower = query.toLowerCase();

      // 1. 인덱스 기반 검색 (빠름)
      if (searchIndex.containsKey(queryLower)) {
        results.addAll(searchIndex[queryLower]!);
      }

      // 2. 부분 문자열 검색 (느리지만 정확)
      final allThemes = LocalStorage.getCachedThemes();
      results.addAll(
        allThemes.where((t) =>
          t.name.toLowerCase().contains(queryLower) ||
          (t.searchKeywords?.toLowerCase().contains(queryLower) ?? false)
        )
      );

      return results.toList();
    }
  }

  🔄 동기화 전략

  3단계 접근법

  class ThemeSearchStrategy {

    // Level 1: 즉시 로컬 검색
    static Future<List<EscapeTheme>> search(String query) async {
      // 1. 로컬 캐시에서 즉시 검색
      final localResults = OfflineSearchService.searchThemes(query);

      // 2. 온라인이면 백그라운드 업데이트
      if (ConnectivityService.isOnline) {
        _backgroundUpdate(query);
      }

      return localResults;
    }

    // Level 2: 백그라운드 업데이트
    static Future<void> _backgroundUpdate(String query) async {
      try {
        // 서버에서 최신 데이터 조회
        final serverResults = await DatabaseService.searchThemes(query);

        // 새로운 테마 발견 시 캐시 업데이트
        final cachedIds = LocalStorage.getCachedThemeIds();
        final newThemes = serverResults.where((t) => !cachedIds.contains(t.id));

        if (newThemes.isNotEmpty) {
          await LocalStorage.addThemes(newThemes);
          // UI 리프레시 트리거
          ThemeUpdateNotifier.notify();
        }
      } catch (e) {
        // 실패 무시 (로컬 결과 이미 표시됨)
      }
    }

    // Level 3: 수동 새로고침
    static Future<void> forceRefresh() async {
      if (!ConnectivityService.isOnline) {
        throw Exception('인터넷 연결이 필요합니다');
      }

      await ThemeCacheService.downloadAllThemes();
    }
  }

  🎨 UI/UX 처리

  검색 화면 구현

  class ThemeSearchWidget extends StatefulWidget {
    @override
    Widget build(BuildContext context) {
      return Column(
        children: [
          // 검색 바
          TextField(
            onChanged: (query) => _search(query),
            decoration: InputDecoration(
              hintText: '테마 또는 카페 검색',
              suffixIcon: _buildStatusIcon(),
            ),
          ),

          // 오프라인 모드 안내 (필요시만)
          if (!isOnline && isDataStale)
            Container(
              color: Colors.orange.shade100,
              padding: EdgeInsets.all(8),
              child: Row(
                children: [
                  Icon(Icons.info_outline, size: 16),
                  SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      '오프라인 모드 - ${lastUpdateDays}일 전 데이터',
                      style: TextStyle(fontSize: 12),
                    ),
                  ),
                  TextButton(
                    onPressed: _requestOnlineUpdate,
                    child: Text('업데이트'),
                  ),
                ],
              ),
            ),

          // 검색 결과
          Expanded(
            child: ListView.builder(
              itemCount: searchResults.length,
              itemBuilder: (context, index) {
                final theme = searchResults[index];
                return ListTile(
                  title: Text(theme.name),
                  subtitle: Text(theme.cafe.name),
                  trailing: _buildDataSourceIcon(theme),
                );
              },
            ),
          ),
        ],
      );
    }

    Widget _buildStatusIcon() {
      if (isSearching) return CircularProgressIndicator(strokeWidth: 2);
      if (!isOnline) return Icon(Icons.offline_bolt, color: Colors.grey);
      if (isDataStale) return Icon(Icons.sync, color: Colors.orange);
      return Icon(Icons.check_circle, color: Colors.green);
    }

    Widget _buildDataSourceIcon(EscapeTheme theme) {
      if (theme.isNewFromServer) {
        return Chip(
          label: Text('NEW', style: TextStyle(fontSize: 10)),
          backgroundColor: Colors.green.shade100,
        );
      }
      return SizedBox.shrink();
    }
  }

  📱 첫 실행 시나리오

  class FirstLaunchExperience {
    static Future<void> initialize() async {
      // 1. 기본 데이터 포함 (앱 번들)
      if (isFirstLaunch) {
        // assets/initial_themes.json 포함
        final bundledData = await loadBundledThemes();
        await LocalStorage.saveThemes(bundledData);

        // 사용자는 즉시 검색 가능!
      }

      // 2. 백그라운드 업데이트
      if (isOnline) {
        Future.delayed(Duration(seconds: 2), () {
          ThemeCacheService.downloadAllThemes();
        });
      }
    }
  }

  🔧 설정 옵션

  class SearchSettings {
    // 사용자 설정
    bool downloadOnWifiOnly = true;
    bool autoUpdateThemes = true;
    int cacheExpiryDays = 7;

    // 설정 UI
    Widget build() {
      return Column(
        children: [
          SwitchListTile(
            title: Text('Wi-Fi에서만 테마 업데이트'),
            value: downloadOnWifiOnly,
          ),
          ListTile(
            title: Text('테마 데이터 관리'),
            subtitle: Text('${cachedThemeCount}개 테마 저장됨 (${cacheSize}MB)'),
            trailing: TextButton(
              child: Text('캐시 삭제'),
              onPressed: clearCache,
            ),
          ),
        ],
      );
    }
  }

  ✅ 결론: 추천 구현 방식

  1. 기본 전략: 로컬 캐시 우선, 백그라운드 업데이트
  2. 초기 데이터: 앱에 기본 데이터 포함 (자주 사용되는 테마 500개)
  3. 업데이트 주기: 주 1회 자동, 수동 새로고침 가능
  4. 오프라인: 완벽 지원 (캐시된 데이터로 검색)
  5. 용량 관리: 1-2MB로 부담 없음

  이렇게 하면 오프라인에서도 검색이 가능하고, 온라인일 때는 항상 최신 데이터를 유지할 수 있습니다!